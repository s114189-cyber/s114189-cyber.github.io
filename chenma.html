<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>合成水果遊戲</title>
<style>
  body {
    margin: 0;
    background: #f2e8c9;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  #container { position: relative; }
  canvas {
    background: #fffbe6;
    border: 3px solid #444;
    touch-action: none;
  }
  button {
    position: absolute;
    top: 10px;
    right: 10px;
  }
</style>
</head>
<body>

<div id="container">
  <canvas id="game" width="360" height="600"></canvas>
  <button onclick="restartConfirm()">重新開始</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRAVITY = 0.35;
const RED_LINE = 60;

let score = 0;
let highScore = localStorage.getItem("highScore") || 0;
let gameOver = false;
let dropX = canvas.width / 2;

const fruits = [
  { r: 12, color: "#ff7676", score: 10 },
  { r: 16, color: "#ff9f43", score: 20 },
  { r: 20, color: "#feca57", score: 40 },
  { r: 24, color: "#1dd1a1", score: 80 },
  { r: 28, color: "#48dbfb", score: 160 },
  { r: 34, color: "#5f27cd", score: 320 },
  { r: 40, color: "#2ecc71", score: 640 },
  { r: 46, color: "#27ae60", score: 1280 }
];

class Ball {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.vy = 0;
    this.type = type;
  }
  get r() { return fruits[this.type].r; }
  update() {
    this.vy += GRAVITY;
    this.y += this.vy;
    if (this.y + this.r > canvas.height) {
      this.y = canvas.height - this.r;
      this.vy *= -0.2;
    }
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fillStyle = fruits[this.type].color;
    ctx.fill();
  }
}

let balls = [];
let nextFruit = Math.floor(Math.random() * 3);

/* 電腦 */
canvas.addEventListener("mousemove", e => {
  const r = canvas.getBoundingClientRect();
  dropX = e.clientX - r.left;
});
canvas.addEventListener("click", dropFruit);

/* 手機 */
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  dropX = e.touches[0].clientX - r.left;
  dropFruit();
}, { passive:false });

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  dropX = e.touches[0].clientX - r.left;
}, { passive:false });

function dropFruit() {
  if (gameOver) return;
  balls.push(new Ball(dropX, RED_LINE + 20, nextFruit));
  nextFruit = Math.floor(Math.random() * 3);
}

function collide(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y) < a.r + b.r;
}

function merge() {
  for (let i = 0; i < balls.length; i++) {
    for (let j = i + 1; j < balls.length; j++) {
      if (balls[i].type === balls[j].type && collide(balls[i], balls[j])) {
        score += fruits[balls[i].type].score;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("highScore", highScore);
        }
        const nx = (balls[i].x + balls[j].x) / 2;
        const ny = (balls[i].y + balls[j].y) / 2;
        const nt = balls[i].type + 1;
        balls.splice(j, 1);
        balls.splice(i, 1);
        if (nt < fruits.length) balls.push(new Ball(nx, ny, nt));
        return;
      }
    }
  }
}

function checkGameOver() {
  balls.forEach(b => {
    if (b.vy < 0.5 && b.y - b.r < RED_LINE) {
      gameOver = true;
    }
  });
}

function drawUI() {
  ctx.fillStyle = "#000";
  ctx.fillText("分數：" + score, 10, 20);
  ctx.fillText("最高分：" + highScore, 10, 40);

  ctx.setLineDash([6,6]);
  ctx.strokeStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, RED_LINE);
  ctx.lineTo(canvas.width, RED_LINE);
  ctx.stroke();
  ctx.setLineDash([]);
}

function restartConfirm() {
  if (confirm("確定要重新開始嗎？")) restart();
}
function restart() {
  balls = [];
  score = 0;
  gameOver = false;
}

function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  balls.forEach(b => { b.update(); b.draw(); });
  merge();
  drawUI();
  checkGameOver();
  if (gameOver) ctx.fillText("Game Over", 120, 300);
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

