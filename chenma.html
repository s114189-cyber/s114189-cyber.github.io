<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>合成水果遊戲（滾動＋摩擦版）</title>
<style>
body{
  margin:0;
  background:#f2e8c9;
  display:flex;
  flex-direction:column;
  align-items:center;
  font-family:sans-serif;
}
canvas{
  background:#fffbe6;
  border:3px solid #444;
}
</style>
</head>
<body>

<canvas id="game" width="360" height="600"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

const GRAVITY=0.6;
const FRICTION=0.985;
const RED_LINE=80;

let targetX=180;
let previewX=180;
let shake=0;

const fruits=[
 {r:20,c:"#f00",s:10},{r:24,c:"#f80",s:20},{r:28,c:"#ff0",s:40},
 {r:32,c:"#7f0",s:80},{r:36,c:"#0f0",s:160},{r:40,c:"#0f7",s:320},
 {r:44,c:"#0ff",s:640},{r:48,c:"#07f",s:1280},{r:52,c:"#00f",s:2560},
 {r:56,c:"#70f",s:5120},{r:60,c:"#f0f",s:10240},{r:64,c:"#f07",s:20480}
];

class Ball{
  constructor(x,y,t){
    this.x=x;
    this.y=y;
    this.vx=0;
    this.vy=0;
    this.t=t;
    this.scale=1;
  }
  get r(){return fruits[this.t].r*this.scale;}
  get color(){return fruits[this.t].c;}

  update(){
    this.vy+=GRAVITY;
    this.x+=this.vx;
    this.y+=this.vy;

    // 牆壁
    if(this.x-this.r<0){this.x=this.r; this.vx*=-0.5;}
    if(this.x+this.r>canvas.width){this.x=canvas.width-this.r; this.vx*=-0.5;}

    // 地板
    if(this.y+this.r>canvas.height){
      this.y=canvas.height-this.r;
      this.vy=0;
      this.vx*=0.9;
    }

    // 球碰撞
    for(const o of balls){
      if(o===this) continue;
      const dx=this.x-o.x;
      const dy=this.y-o.y;
      const d=Math.hypot(dx,dy);
      const min=this.r+o.r;

      if(d<min && d>0){
        const nx=dx/d, ny=dy/d;
        const overlap=min-d;

        this.x+=nx*overlap/2;
        this.y+=ny*overlap/2;
        o.x-=nx*overlap/2;
        o.y-=ny*overlap/2;

        // 側向滾動
        this.vx+=nx*0.6;
        o.vx-=nx*0.6;

        // 合成
        if(this.color===o.color){
          merge(this,o);
          return;
        }
      }
    }

    // 摩擦
    this.vx*=FRICTION;
    this.scale+=(1-this.scale)*0.2;
  }

  draw(){
    ctx.save();
    ctx.translate(this.x,this.y);
    ctx.scale(this.scale,this.scale);
    ctx.beginPath();
    ctx.arc(0,0,fruits[this.t].r,0,Math.PI*2);
    ctx.fillStyle=this.color;
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }
}

let balls=[];
let next=Math.floor(Math.random()*3);

function drop(){
  balls.push(new Ball(previewX,RED_LINE+50,next));
  next=Math.floor(Math.random()*3);
}

function merge(a,b){
  const nx=(a.x+b.x)/2;
  const ny=(a.y+b.y)/2;
  balls=balls.filter(x=>x!==a&&x!==b);
  if(a.t+1<fruits.length){
    const nb=new Ball(nx,ny,a.t+1);
    nb.vy=-2;
    nb.scale=1.4;
    balls.push(nb);
  }
  shake=8;
}

// 操作
canvas.addEventListener("mousemove",e=>targetX=e.offsetX);
canvas.addEventListener("click",drop);
canvas.addEventListener("touchmove",e=>{
  targetX=e.touches[0].clientX-canvas.getBoundingClientRect().left;
});
canvas.addEventListener("touchend",drop);

function loop(){
  ctx.setTransform(1,0,0,1,0,0);
  if(shake>0){
    ctx.translate(Math.random()*6-3,Math.random()*6-3);
    shake--;
  }
  ctx.clearRect(0,0,360,600);

  // 紅線警告
  const warn=balls.some(b=>b.y-b.r<RED_LINE+20);
  ctx.strokeStyle=warn&&Math.sin(Date.now()/100)>0?"#f00":"#faa";
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(0,RED_LINE);
  ctx.lineTo(360,RED_LINE);
  ctx.stroke();

  // 預覽球（彈性）
  previewX+= (targetX-previewX)*0.25;
  const p=fruits[next];
  ctx.beginPath();
  ctx.arc(previewX,45,p.r*1.2,0,Math.PI*2);
  ctx.fillStyle=p.c;
  ctx.fill();
  ctx.stroke();

  balls.forEach(b=>{b.update();b.draw();});
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
