<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>合成大西瓜（有臉版）</title>
<style>
body{
  margin:0;
  background:#f2e8c9;
  display:flex;
  flex-direction:column;
  align-items:center;
  font-family:sans-serif;
  user-select:none;
}
canvas{
  background:#fffbe6;
  border:3px solid #444;
}
#score,#order{
  width:360px;
  margin-top:6px;
}
#order{
  display:flex;
  flex-wrap:wrap;
  gap:4px;
}
.orderBall{
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  font-weight:bold;
}
button{ margin-top:6px; }
</style>
</head>
<body>

<canvas id="game" width="360" height="600"></canvas>
<div id="score"></div>
<button onclick="restart()">重新開始</button>
<div id="order"></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreDiv = document.getElementById("score");
const orderDiv = document.getElementById("order");

const GRAVITY = 0.7;
const RED_LINE = 80;

let score = 0;
let shake = 0;
let high = localStorage.getItem("melonHigh") || 0;

const fruits = [
 {r:20,c:"#f00",s:10},{r:24,c:"#f80",s:20},{r:28,c:"#ff0",s:40},
 {r:32,c:"#7f0",s:80},{r:36,c:"#0f0",s:160},{r:40,c:"#0f7",s:320},
 {r:44,c:"#0ff",s:640},{r:48,c:"#07f",s:1280},{r:52,c:"#00f",s:2560},
 {r:56,c:"#70f",s:5120},{r:60,c:"#f0f",s:10240},{r:64,c:"#f07",s:20480}
];

const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

class Ball{
  constructor(x,y,t){
    this.x=x;
    this.y=y;
    this.vy=0;
    this.t=t;
    this.scale=1;
    this.settled=false;
  }

  get r(){ return fruits[this.t].r * this.scale; }
  get color(){ return fruits[this.t].c; }

  update(){
    if(!this.settled){
      this.vy += GRAVITY;
      this.y += this.vy;
    }

    this.x = clamp(this.x, this.r, canvas.width - this.r);

    // 合成 & 推擠
    for(const o of balls){
      if(o === this) continue;
      const dx = this.x - o.x;
      const dy = this.y - o.y;
      const d = Math.hypot(dx,dy);
      const min = this.r + o.r;

      if(d < min && d > 0){
        const nx = dx / d;
        const ny = dy / d;

        if(this.t === o.t){
          mergeBalls(this,o);
          return;
        }else{
          const overlap = min - d;
          this.x += nx * overlap * 0.5;
          this.y += ny * overlap * 0.5;
        }
      }
    }

    // 堆疊支撐
    let maxY = canvas.height - this.r;
    let supported = false;

    for(const o of balls){
      if(o === this) continue;
      if(Math.abs(o.x - this.x) < this.r * 1.05 && o.y > this.y){
        const y = o.y - o.r - this.r;
        if(y < maxY){
          maxY = y;
          supported = true;
        }
      }
    }

    if(this.y >= maxY){
      this.y = maxY;
      this.vy = 0;
      this.settled = supported;
    }else{
      this.settled = false;
    }
  }

  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.scale, this.scale);

    const r = fruits[this.t].r;

    // 球
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.strokeStyle="#333";
    ctx.lineWidth=2;
    ctx.stroke();

    // 狀態
    const fastFall = this.vy > 8;
    const bigFruit = this.t >= 6;

    // 眼睛看方向
    const lookX = clamp(this.vy * 0.05, -r*0.15, r*0.15);
    const eyeX = r*0.35;
    const eyeY = -r*0.25;
    const eyeR = r*0.1;

    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.arc(-eyeX+lookX, eyeY, eyeR, 0, Math.PI*2);
    ctx.arc( eyeX+lookX, eyeY, eyeR, 0, Math.PI*2);
    ctx.fill();

    // 嘴巴
    ctx.strokeStyle="#000";
    ctx.lineWidth=r*0.08;
    ctx.beginPath();

    if(fastFall){
      ctx.arc(0, r*0.2, r*0.18, 0, Math.PI*2);
    }else if(bigFruit){
      ctx.moveTo(-r*0.25, r*0.25);
      ctx.lineTo( r*0.25, r*0.25);
    }else{
      ctx.arc(0, r*0.15, r*0.35, 0, Math.PI);
    }

    ctx.stroke();
    ctx.restore();

    this.scale += (1 - this.scale) * 0.15;
  }
}

let balls=[];
let targetX=180;
let previewX=180;
let next=Math.floor(Math.random()*3);
let canDrop=true;

function drop(){
  if(!canDrop) return;
  canDrop=false;
  balls.push(new Ball(previewX, RED_LINE+50, next));
  next=Math.floor(Math.random()*3);
  setTimeout(()=>canDrop=true,200);
}

function mergeBalls(a,b){
  const x=(a.x+b.x)/2;
  const y=(a.y+b.y)/2;
  score+=fruits[a.t].s;
  high=Math.max(high,score);
  localStorage.setItem("melonHigh",high);
  balls=balls.filter(v=>v!==a&&v!==b);
  const n=new Ball(x,y,a.t+1);
  n.scale=1.5;
  balls.push(n);
  shake=8;
}

// 操作
canvas.addEventListener("mousemove",e=>targetX=clamp(e.offsetX,0,canvas.width));
canvas.addEventListener("click",drop);

function loop(){
  ctx.setTransform(1,0,0,1,0,0);
  if(shake>0){ ctx.translate(Math.random()*6-3,Math.random()*6-3); shake--; }
  ctx.clearRect(0,0,360,600);

  previewX += (targetX-previewX)*0.25;
  previewX = clamp(previewX, fruits[next].r, canvas.width-fruits[next].r);

  const p = fruits[next];
  ctx.beginPath();
  ctx.arc(previewX,45,p.r*1.2,0,Math.PI*2);
  ctx.fillStyle=p.c;
  ctx.fill();
  ctx.stroke();

  balls.forEach(b=>{b.update();b.draw();});
  scoreDiv.innerText=`分數:${score}  最高:${high}`;
  requestAnimationFrame(loop);
}
loop();

function restart(){
  balls=[];
  score=0;
  next=Math.floor(Math.random()*3);
}

// 合成順序
fruits.forEach((f,i)=>{
  const d=document.createElement("div");
  d.className="orderBall";
  d.style.width=d.style.height=f.r*0.9+"px";
  d.style.background=f.c;
  d.innerText=i+1;
  orderDiv.appendChild(d);
});
</script>
</body>
</html>

